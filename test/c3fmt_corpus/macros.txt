================================================================================
simple_macro
================================================================================

macro    

main() { return;}

--------------------------------------------------------------------------------

macro main()
{
    return;
}

================================================================================
simple_ct_macro
================================================================================

macro @m(
#x 

, y
)
{  #x = 2 * y;
}

--------------------------------------------------------------------------------

macro @m(#x, y)
{
    #x = 2 * y;
}

================================================================================
simple_macro_ct_type
================================================================================

macro size($Type)
{
    return $Type.sizeof + 

    int.sizeof;
}
--------------------------------------------------------------------------------

macro size($Type)
{
    return $Type.sizeof + int.sizeof;
}

================================================================================
simple_macro_body_definition
================================================================================

macro SomeType   * !
   @for_each(   list   ; @body(   it  ))
{
    for ($typeof(list)
    x = list; x;
    x = x.next)
    {
    @body(x);
    }
}
--------------------------------------------------------------------------------

macro SomeType*! @for_each(list; @body(it))
{
    for ($typeof(list) x = list; x; x = x.next) {
        @body(x);
    }
}

================================================================================
name_fields
================================================================================

macro usz @offset($Type, #field)
{
        $Type* t = null;
    return (usz)

    (uptr)  &    t   .   #field;
}

--------------------------------------------------------------------------------

macro usz @offset($Type, #field)
{
    $Type* t = null;
    return (usz)(uptr)&t.#field;
}

================================================================================
hash_macro
================================================================================

macro Foo.@check(#expr, $Type t, args...)
{
    if ( !  
    #expr)
    abort(
    $stringify(#expr
    ));
}

--------------------------------------------------------------------------------

macro Foo.@check(#expr, $Type t, args...)
{
    if (!#expr) abort($stringify(#expr));
}

================================================================================
hash_macro_with_contracts
================================================================================
<*
@require $defined(#a=#b,#b= #a)
*>
macro void @swap(#a,     #b)
{
        var temp = #a;
    #a = #b;
        #b = temp;
}

--------------------------------------------------------------------------------

<*
@require $defined(#a = #b, #b = #a)
*>
macro void @swap(#a, #b)
{
    var temp = #a;
    #a = #b;
    #b = temp;
}

================================================================================
ct_if_else
================================================================================
macro @foo($x, #y)
{
    $if $x > 3:
    #y += $x * $x;
    $endif

    $if $x > 3:  #y += $x * $x; $else  #y += $x; $endif
}
--------------------------------------------------------------------------------

macro @foo($x, #y)
{
    $if $x > 3:
        #y += $x * $x;
    $endif

    $if $x > 3:
        #y += $x * $x;
    $else
        #y += $x;
    $endif
}

================================================================================
ct_for_in_ct_scope
================================================================================
macro foo($a)
{
    $if $x > 3:
    $for (var $x = 0; $x < $a; $x++)
io::printfn("%d", $x);
    $endfor
    $endif
}

--------------------------------------------------------------------------------

macro foo($a)
{
    $if $x > 3:
        $for (var $x = 0; $x < $a; $x++)
            io::printfn("%d", $x);
        $endfor
    $endif
}

================================================================================
ct_foreach
================================================================================
macro foo_enum($SomeEnum)
{
    $if $x > 3:
    $foreach ($x : $SomeEnum.values)
    io::printfn("%d", (int)$x);
    $endforeach
    $endif
}

--------------------------------------------------------------------------------

macro foo_enum($SomeEnum)
{
    $if $x > 3:
        $foreach ($x : $SomeEnum.values)
            io::printfn("%d", (int)$x);
        $endforeach
    $endif
}

================================================================================
ct_switch
================================================================================
macro @foo($x, #y)
{
    $if $x > 3:
    $switch ($x)
        $case 0:
        $case 1:
            #y += $x * $x;
        $case 2:
            #y += $x;
        $case 3:
        $case $x > 10&&!$x:
            $if $x > 3:
            #y *= $x;
            $endif
        $default:
            #y -= $x;
    $endswitch
    $endif
}

--------------------------------------------------------------------------------

macro @foo($x, #y)
{
    $if $x > 3:
        $switch ($x)
            $case 0:
            $case 1:
                #y += $x * $x;
            $case 2:
                #y += $x;
            $case 3:
            $case $x > 10 && !$x:
                $if $x > 3:
                    #y *= $x;
                $endif
            $default:
                #y -= $x;
        $endswitch
    $endif
}

================================================================================
ct_switch_no_top_cond
================================================================================
macro @foo($x, #y)
{
    $if $x > 3:
    $switch
        $case 0:
        $case 1:
            #y += $x * $x;
            if(#y) { return 0;}
        $case 2:
            #y += $x;
        $case 3:
        $case $x > 10&&!$x:
            $if $x > 3:
            #y *= $x;
            $endif
        $default:
            #y -= $x;
    $endswitch
    $endif
}

--------------------------------------------------------------------------------

macro @foo($x, #y)
{
    $if $x > 3:
        $switch
            $case 0:
            $case 1:
                #y += $x * $x;
                if (#y) {
                    return 0;
                }
            $case 2:
                #y += $x;
            $case 3:
            $case $x > 10 && !$x:
                $if $x > 3:
                    #y *= $x;
                $endif
            $default:
                #y -= $x;
        $endswitch
    $endif
}

================================================================================
ct_if_call_colon_position
================================================================================
macro @foo($x, #y)
{
    $if type_is_overaligned(foo,bar: soo):
    #y += $x * $x;
    $endif
}
--------------------------------------------------------------------------------

macro @foo($x, #y)
{
    $if type_is_overaligned(foo, bar: soo):
        #y += $x * $x;
    $endif
}

================================================================================
body_macro_with_vector_init
================================================================================
macro void Slice2d.@each(&self; @body(usz[<2>], Type))
{
    foreach (y, line : *self)
    {
        foreach (x, val : line)
        {
            @body({ x, y }, val);
        }
    }
}

--------------------------------------------------------------------------------

macro void Slice2d.@each(&self; @body(usz[<2>], Type))
{
    foreach (y, line : *self) {
        foreach (x, val : line) {
            @body({x, y}, val);
        }
    }
}

================================================================================
mem_scoped_stack_pool
================================================================================
macro void @stack_pool(usz $size; @body) @builtin
{
    mem::@scoped(&allocator){ @body(); };
}
--------------------------------------------------------------------------------

macro void @stack_pool(usz $size; @body) @builtin
{
    mem::@scoped(&allocator) {
        @body();
    };
}

================================================================================
ct_if_else_inside_other
================================================================================
macro @foo($x, #y)
{
    $if $x > 3:
    #y += $x * $x;
        $if $x > 3:  #y += $x * $x; $else  #y += $x; $endif
    $endif

}
--------------------------------------------------------------------------------

macro @foo($x, #y)
{
    $if $x > 3:
        #y += $x * $x;
        $if $x > 3:
            #y += $x * $x;
        $else
            #y += $x;
        $endif
    $endif

}

================================================================================
ct_foreach_in_other
================================================================================
macro foo_enum($SomeEnum)
{
    $if $x > 3:
    $foreach ($x : $SomeEnum.values)
    $foreach ($x : $SomeEnum.values)
    io::printfn("%d", (int)$x);
    $endforeach
    $endforeach
    $endif
}

--------------------------------------------------------------------------------

macro foo_enum($SomeEnum)
{
    $if $x > 3:
        $foreach ($x : $SomeEnum.values)
            $foreach ($x : $SomeEnum.values)
                io::printfn("%d", (int)$x);
            $endforeach
        $endforeach
    $endif
}

================================================================================
ct_switch_in_other
================================================================================
macro @foo($x, #y)
{
    $switch ($x)
        $case 1:
            $switch ($x)
                $case 1:
                $default:
                    #y -= $x;
            $endswitch
        $default:
            #y -= $x;
            $switch ($x)
                $case 2:
                $default:
                    #y -= $x;
            $endswitch
    $endswitch
}
--------------------------------------------------------------------------------

macro @foo($x, #y)
{
    $switch ($x)
        $case 1:
            $switch ($x)
                $case 1:
                $default:
                    #y -= $x;
            $endswitch
        $default:
            #y -= $x;
            $switch ($x)
                $case 2:
                $default:
                    #y -= $x;
            $endswitch
    $endswitch
}

================================================================================
matrix_component_mul
================================================================================
macro matrix_component_mul(mat, val) @private
{
    var $Type = Real[<$typeof(mat.m).len>];
    return $typeof(*mat) { .m = val * ($Type)mat.m };
}
--------------------------------------------------------------------------------

macro matrix_component_mul(mat, val) @private
{
    var $Type = Real[<$typeof(mat.m).len>];
    return $typeof(*mat){ .m = val * ($Type)mat.m };
}


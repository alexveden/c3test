================================================================================
expressions
================================================================================

fn void main() 
{ 
int a = b*2/1-1+3%1;
b%= 10+a;
b&=a;
b|=a;
b^=a;
b&&&a;
b|||a;
b+++a;
b/=a;
a==s;
a>=s;
a<=s;
a>=s;
a-=s;
a+=s;
a*=s;
a%=s;
a!=s;
a  ++  s;
--  a;
a<<1;
a>>1;
return;
}

--------------------------------------------------------------------------------

fn void main()
{
    int a = b * 2 / 1 - 1 + 3 % 1;
    b %= 10 + a;
    b &= a;
    b |= a;
    b ^= a;
    b &&& a;
    b ||| a;
    b +++ a;
    b /= a;
    a == s;
    a >= s;
    a <= s;
    a >= s;
    a -= s;
    a += s;
    a *= s;
    a %= s;
    a != s;
    a++s;
    --a;
    a << 1;
    a >> 1;
    return;
}

================================================================================
simple_expressions
================================================================================

fn void 
main() { 
bool a =(a||b)&&c; 
int bin = (1&2)&3;
int bin = &a + (1&2)|&a;
int* bin = (int*)&a;
b = *(int*)&a;
b = (*a = 2);
b = { .work = 1, .work=2 };
int** ptr = &(*(int*)&a);
 (  void) free(data);
    (void * * )free(data);
    int* bin = &&1;
return;
}

--------------------------------------------------------------------------------

fn void main()
{
    bool a = (a || b) && c;
    int bin = (1 & 2) & 3;
    int bin = &a + (1 & 2) | &a;
    int* bin = (int*)&a;
    b = *(int*)&a;
    b = (*a = 2);
    b = { .work = 1, .work = 2 };
    int** ptr = &(*(int*)&a);
    (void)free(data);
    (void**)free(data);
    int* bin = &&1;
    return;
}

================================================================================
ternary
================================================================================

fn void 
main() { 
bool a = foo    ? bar   : 1;
return file ?: file_open_errno()?;
return i ?: Foo.X?;
return x ?: (y ?: x);
assert((root.get_int("yyy") ?? -1) == -1);
double x = ((double)testError() + testError()) ?? 100;
io::printfn("6:%s", @catch((3 > 2 ? Foo.ABC? : 4) ?? Foo.DEF?));
}

--------------------------------------------------------------------------------

fn void main()
{
    bool a = foo ? bar : 1;
    return file ?: file_open_errno() ?;
    return i ?: Foo.X?;
    return x ?: (y ?: x);
    assert((root.get_int("yyy") ?? - 1) == -1);
    double x = ((double)testError() + testError()) ?? 100;
    io::printfn("6:%s", @catch((3 > 2 ? Foo.ABC? : 4) ?? Foo.DEF?));
}

================================================================================
numbers
================================================================================

fn void 
main() { 
int a = -1;
int a = -float.inf;
int a = 3 -float.inf;
int a = 3+1;
return +1;
return 1;
int a = (usz)-1;
int a = -add(-2, -3);
return (usz)+1.234f;
return a == -1;
}

--------------------------------------------------------------------------------

fn void main()
{
    int a = -1;
    int a = -float.inf;
    int a = 3 - float.inf;
    int a = 3 + 1;
    return +1;
    return 1;
    int a = (usz)-1;
    int a = -add(-2, -3);
    return (usz)+1.234f;
    return a == -1;
}

================================================================================
generic_vec_expr
================================================================================

fn void main() { 
List(<Foo*>) lfoo;
List(<Foo*>)* lfoo = List(<Foo*>){}.init(bar: 1);
int[<2>]* lfoo = int[<2 >]{}.init(bar: 1);
}

--------------------------------------------------------------------------------

fn void main()
{
    List(<Foo*>) lfoo;
    List(<Foo*>)* lfoo = List(<Foo*>){}.init(bar: 1);
    int[<2>]* lfoo = int[<2>]{}.init(bar: 1);
}

================================================================================
conditional_expr_multi_parens_multiline
================================================================================
macro bool char_is_base64(char c)
{
    return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')
                || c == '+' || c == '/');
}
--------------------------------------------------------------------------------

macro bool char_is_base64(char c)
{
    return (
        (c >= 'A' && c <= 'Z') ||
        (c >= 'a' && c <= 'z') ||
        (c >= '0' && c <= '9') ||
        c == '+' ||
        c == '/'
    );
}

================================================================================
conditional_expr_multi_parens_single_line
================================================================================
macro bool char_is_base64(char c)
{
    return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9'));
}
--------------------------------------------------------------------------------

macro bool char_is_base64(char c)
{
    return (
        (c >= 'A' && c <= 'Z') ||
        (c >= 'a' && c <= 'z') ||
        (c >= '0' && c <= '9')
    );
}

================================================================================
call_with_parens_single_line_wrap
================================================================================
macro bool char_is_base64(char c)
{
    return its_along_call((arg_long_ags+1), (foo ?(bar) : baz), (a && b && coooooooooool) );
    return its_along_call((arg_long_ags+1), (foo ?bar : baz), (a && b && coooooooooool) );
}
--------------------------------------------------------------------------------

macro bool char_is_base64(char c)
{
    return its_along_call(
        (arg_long_ags + 1), (foo ? (bar) : baz), (a && b && coooooooooool)
    );
    return its_along_call(
        (arg_long_ags + 1), (foo ? bar : baz), (a && b && coooooooooool)
    );
}

================================================================================
call_with_parens_multi_line_wrap
================================================================================
macro bool char_is_base64(char c)
{
    return its_along_call((arg_long_ags+1), (foo ?(bar) : baz), (a && b && coooooooooool), (a | super + too_long ) );
}
--------------------------------------------------------------------------------

macro bool char_is_base64(char c)
{
    return its_along_call(
        (arg_long_ags + 1),
        (foo ? (bar) : baz),
        (a && b && coooooooooool),
        (a | super + too_long)
    );
}


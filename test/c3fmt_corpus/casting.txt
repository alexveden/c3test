================================================================================
fn_with_lambda_arg
================================================================================
fn void remove_using_test()
{
    removed = test.remove_using_test(fn bool(i, ctx) => *i >= *(int*)ctx, &&10);
}
--------------------------------------------------------------------------------

fn void remove_using_test()
{
    removed = test.remove_using_test(fn bool (i, ctx) => *i >= *(int*)ctx, &&10);
}

================================================================================
casting_pointers
================================================================================

fn void * 
main(int* arg) { 
bool a =(a||b)&&c; 
int bin = (1&2)&3;
int bin = &a + (1&2)*&a;
int bin = &a + (1&2)+&a;
int bin = &a + (1&2)-&a;
int* bin = (int*)&a;
*bin = 1;
*bin = *foo;
b = *(int*)&a;
*(int*)&a = 2;
b = (*a = 2);
b = { .work = 1, .work=2};
int** ptr = &(*(int*)&a);
 (  void) free(data);
    (void * * )free(data);
    int* bin = &&1;

call(&StrucType.fn_ptr);
    node = ($typeof(self))node.next;            
    node = ($typeof(#self))node.next;            
    node = ($typeof(#self[0]))node.next;            
    node = ($Type*)node.next;            
    defer (void)f.close();
    return (*(char[8]*))foo;
    return (char[8])foo;
    return &StrucType.fn;
    node = some_fn(&&node.next);            
    node = a + *b;
    node = ( (w | x) & y) + &(w & y);
    node = (void*.alignof) * 2;
    node = size & PAGE;
    node = (*h ^ ($typeof(*h))x) * FOO;
    node = a + *(int*)b;
    return (char[?])foo;
    return { q.v[0] * -foo};
    node = ((int*)*self & (int)bar);
    node = ((int*)*self & ~(int)bar);
    node = (*h * ($typeof(*h))x) & FOO;
}

--------------------------------------------------------------------------------

fn void* main(int* arg)
{
    bool a = (a || b) && c;
    int bin = (1 & 2) & 3;
    int bin = &a + (1 & 2) * &a;
    int bin = &a + (1 & 2) + &a;
    int bin = &a + (1 & 2) - &a;
    int* bin = (int*)&a;
    *bin = 1;
    *bin = *foo;
    b = *(int*)&a;
    *(int*)&a = 2;
    b = (*a = 2);
    b = { .work = 1, .work = 2 };
    int** ptr = & (*(int*)&a);
    (void)free(data);
    (void**)free(data);
    int* bin = &&1;

    call(&StrucType.fn_ptr);
    node = ($typeof(self))node.next;
    node = ($typeof(#self))node.next;
    node = ($typeof(#self[0]))node.next;
    node = ($Type*)node.next;
    defer (void) f.close();
    return (*(char[8]*))foo;
    return (char[8])foo;
    return &StrucType.fn;
    node = some_fn(&&node.next);
    node = a + *b;
    node = ((w | x) & y) + & (w & y);
    node = (void*.alignof) * 2;
    node = size & PAGE;
    node = (*h ^ ($typeof(*h))x) * FOO;
    node = a + *(int*)b;
    return (char[?])foo;
    return { q.v[0] * -foo };
    node = ((int*)*self & (int)bar);
    node = ((int*)*self & ~(int)bar);
    node = (*h * ($typeof(*h))x) & FOO;
}

